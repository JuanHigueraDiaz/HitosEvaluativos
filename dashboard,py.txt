#!/usr/bin/env python3
# Proyecto ECO-SENSE 1.0
# Script del Dashboard de visualizaciÃ³n en Streamlit.

import streamlit as st
import pandas as pd
import numpy as np
import altair as alt
import time
import os

# --- ConfiguraciÃ³n Global ---
NOMBRE_ARCHIVO_CSV = 'historial_mediciones_robot.csv'
TIEMPO_REFRESCO = 3

LIMITE_TEMP_ALTA = 60.0
LIMITE_CORRIENTE = 2.0
LIMITE_TEMP_BAJA = 10.0
LIMITE_AMARILLO_TEMP = 58.0
LIMITE_AMARILLO_CORR = 1.8
VOLTAJE_LINEA = 220

# --- ConfiguraciÃ³n de la PÃ¡gina de Streamlit ---
st.set_page_config(
    page_title="Dashboard ECO-SENSE 1.0 (HÃ­brido)",
    page_icon="ğŸ­",
    layout="wide"
)

st.title("ğŸ­ Dashboard ECO-SENSE 1.0 (Datos HÃ­bridos)")
st.caption(f"T/H/V (Real) | Corriente/Piezas (Sim/Contado). (v5)")


# --- FunciÃ³n para Cargar Datos (con cachÃ©) ---

# El 'ttl=3' le dice a Streamlit que vuelva a cargar los datos
# si han pasado mÃ¡s de 3 segundos.
@st.cache_data(ttl=TIEMPO_REFRESCO)
def cargar_datos(nombre_archivo):
    # El dashboard espera un CSV con estas 7 columnas
    columnas_esperadas = ['timestamp', 'lote', 'temperatura', 'humedad', 'voltaje_real', 'corriente_sim',
                          'piezas_contadas']

    if not os.path.exists(nombre_archivo):
        return pd.DataFrame(columns=columnas_esperadas)
    try:
        df = pd.read_csv(nombre_archivo)
        df['timestamp'] = pd.to_datetime(df['timestamp'], errors='coerce')
        df = df.dropna(subset=['timestamp'])
        return df
    except pd.errors.EmptyDataError:
        return pd.DataFrame(columns=columnas_esperadas)
    except Exception as e:
        st.error(f"Error al cargar CSV: {e}")
        return pd.DataFrame(columns=columnas_esperadas)


# --- Cuerpo Principal del Dashboard ---

df = cargar_datos(NOMBRE_ARCHIVO_CSV)

if df.empty:
    st.warning("Esperando los primeros datos... (AsegÃºrate de que el script del Robot estÃ© corriendo)")
    st.stop()

try:
    # Saca la Ãºltima fila de datos para los semÃ¡foros
    ultima_lectura = df.iloc[-1]
    ultima_temp = ultima_lectura['temperatura']
    ultima_hum = ultima_lectura['humedad']
    ultima_volt = ultima_lectura['voltaje_real']
    ultima_corr = ultima_lectura['corriente_sim']
    ultimo_lote = ultima_lectura['lote']
    ultimo_timestamp = ultima_lectura['timestamp'].strftime("%H:%M:%S")
except IndexError:
    st.warning("Archivo CSV encontrado, pero aÃºn no hay lecturas de datos...")
    st.stop()

# SemÃ¡foros de Estado (KPIs)
st.subheader("ğŸš¦ SemÃ¡foros de Estado")
col_temp, col_corr, col_piezas = st.columns(3)

with col_temp:
    if ultima_temp >= LIMITE_TEMP_ALTA:
        st.error(f"ğŸ”´ ALERTA ALTA: {ultima_temp:.1f} Â°C", icon="ğŸ”¥")
    elif ultima_temp <= LIMITE_TEMP_BAJA:
        st.error(f"ğŸ”´ ALERTA BAJA: {ultima_temp:.1f} Â°C", icon="â„ï¸")
    elif ultima_temp >= LIMITE_AMARILLO_TEMP:
        st.warning(f"ğŸŸ¡ ADVERTENCIA: {ultima_temp:.1f} Â°C", icon="âš ï¸")
    else:
        st.success(f"ğŸŸ¢ NORMAL TÂ°: {ultima_temp:.1f} Â°C", icon="âœ…")

with col_corr:
    if ultima_corr >= LIMITE_CORRIENTE:
        st.error(f"ğŸ”´ ALERTA I (Sim): {ultima_corr:.2f} A", icon="âš¡")
    elif ultima_corr >= LIMITE_AMARILLO_CORR:
        st.warning(f"ğŸŸ¡ ADVERTENCIA I (Sim): {ultima_corr:.2f} A", icon="âš ï¸")
    else:
        st.success(f"ğŸŸ¢ NORMAL I (Sim): {ultima_corr:.2f} A", icon="âœ…")

with col_piezas:
    total_piezas = df['piezas_contadas'].sum()
    st.metric(label="ğŸ“¦ Total Piezas (Contadas)", value=f"{total_piezas}")

st.info(f"Ãšltima lectura: **{ultimo_lote}** a las **{ultimo_timestamp}**")
st.divider()

# Tabla de Ãšltimas 3 Mediciones
st.subheader("ğŸ•’ Ãšltimas 3 Mediciones")
st.dataframe(df.tail(3), use_container_width=True)
st.divider()

# GrÃ¡ficos HistÃ³ricos (TÂ°, Humedad, Corriente)
st.subheader("ğŸ“ˆ Historial de Sensores")
col_g1, col_g2, col_g3 = st.columns(3)

with col_g1:
    st.text("GrÃ¡fico de Temperatura (Real)")
    chart_temp = alt.Chart(df).mark_line(point=True, color='orange').encode(
        x=alt.X('timestamp', title='Tiempo'),
        y=alt.Y('temperatura', title='Temperatura (Â°C)'),
        tooltip=['timestamp', 'lote', 'temperatura']
    ).interactive()
    st.altair_chart(chart_temp, use_container_width=True)

with col_g2:
    st.text("GrÃ¡fico de Humedad (Real)")
    chart_hum = alt.Chart(df).mark_line(point=True, color='green').encode(
        x=alt.X('timestamp', title='Tiempo'),
        y=alt.Y('humedad', title='Humedad (%)'),
        tooltip=['timestamp', 'lote', 'humedad']
    ).interactive()
    st.altair_chart(chart_hum, use_container_width=True)

with col_g3:
    st.text("GrÃ¡fico de Corriente (Simulada)")
    chart_corr = alt.Chart(df).mark_line(point=True, color='blue').encode(
        x=alt.X('timestamp', title='Tiempo'),
        y=alt.Y('corriente_sim', title='Corriente (A)'),
        tooltip=['timestamp', 'lote', 'corriente_sim']
    ).interactive()
    st.altair_chart(chart_corr, use_container_width=True)
st.divider()

# AnÃ¡lisis de Promedios (Pandas)
st.subheader("ğŸ“Š AnÃ¡lisis de Promedios (Pandas/NumPy)")

promedios_por_lote = df.groupby('lote')[
    ['temperatura', 'humedad', 'voltaje_real', 'corriente_sim', 'piezas_contadas']].mean()

# Calcula el kWh *estimado* para cada lote (basado en la pausa de 10s)
PAUSA_MEDICION = 10
promedios_por_lote['kWh_por_lote (Estimado)'] = \
    (promedios_por_lote['corriente_sim'] * VOLTAJE_LINEA * PAUSA_MEDICION) / 3600000.0

st.dataframe(promedios_por_lote, use_container_width=True)

# Auto-Refresco
time.sleep(TIEMPO_REFRESCO)
st.rerun()